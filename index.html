<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<title>Atelier — Viewfinder for Artists</title>
<link rel="manifest" href="manifest.json">
<style>
:root{
  --bg:#0b0c0e;
  --panel:#15171b;
  --panel-soft:#1f2228;
  --ink:#f4f6f8;
  --muted:#9aa0a6;
  --accent:#7dd3fc;
  --grid-green:#4ade80;
  --ratio-blue:#60a5fa;
  --root-purple:#c084fc;
  --line:rgba(255,255,255,.38);
  --harmonic:rgba(125,211,252,.5);
  --radius:14px;
}
*{box-sizing:border-box}
html, body{
  margin:0;
  padding:0;
  width:100%;
  height:100%;
  overflow:hidden;
  position:fixed;
}
body{
  background:var(--bg);
  color:var(--ink);
  font-family:-apple-system,BlinkMacSystemFont,Inter,system-ui,sans-serif;
  display:flex;
  flex-direction:column;
}
header.title{
  position:absolute;
  top:8px;
  right:12px;
  z-index:20;
  padding:6px 10px;
  font-weight:600;
  font-size:13px;
  background:rgba(0,0,0,0.35);
  border-radius:8px;
  pointer-events:none;
}

.stage{
  position:relative;
  flex:1;
  background:black;
  overflow:hidden;
  width:100%;
  height:100%;
  padding:50px 12px 80px 12px;
}
video{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  display:none;
}
canvas{
  position:absolute;
  inset:0;
  touch-action: none;
  /* CRITICAL: Prevent scaling issues */
  image-rendering: -webkit-optimize-contrast;
  image-rendering: crisp-edges;
}
.toolbar{
  position:fixed;
  bottom:0;
  left:0;
  right:0;
  width:100%;
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:8px;
  padding:10px;
  background:var(--panel);
  border-top:1px solid #222;
  z-index:30;
  /* CRITICAL: Force pixel-perfect rendering */
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}
.tool{
  background:var(--panel-soft);
  border-radius:var(--radius);
  padding:10px 6px;
  font-size:13px;
  text-align:center;
  color:var(--muted);
  cursor:pointer;
  user-select:none;
  /* CRITICAL: Prevent subpixel rendering issues */
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
}
.tool.active{color:var(--accent);background:#24303a}
.panel{
  position:fixed;
  left:0;
  right:0;
  bottom:72px;
  max-height:50vh;
  background:var(--panel);
  border-top:1px solid #222;
  padding:12px;
  display:none;
  overflow-y:auto;
  z-index:25;
  /* CRITICAL: Force pixel-perfect rendering */
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
}

.panel h4{margin:0 0 10px;font-size:13px;color:var(--muted)}
.option{
  padding:9px;
  border-radius:10px;
  background:var(--panel-soft);
  margin-bottom:8px;
  font-size:13px;
  cursor:pointer;
}

.topbar{
  position:absolute;
  top:8px;
  left:8px;
  display:flex;
  gap:6px;
  z-index:10;
  flex-wrap:wrap;
}

.overlayToggles{
  position:absolute;
  top:8px;
  right:140px;
  display:flex;
  gap:6px;
  z-index:10;
}

.toggleBtn{
  width:36px;
  height:36px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:var(--panel-soft);
  border:none;
  border-radius:10px;
  cursor:pointer;
  opacity:0.5;
  transition:opacity 0.2s;
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
}

.toggleBtn.active{
  opacity:1;
}

.toggleBtn.grid-toggle svg{
  color:var(--grid-green);
}

.toggleBtn.ratio-toggle svg{
  color:var(--ratio-blue);
}

.toggleBtn.root-toggle svg{
  color:var(--root-purple);
}
.topbtn{
  display:flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  font-size:12px;
  background:var(--panel-soft);
  color:var(--ink);
  border:none;
  border-radius:10px;
  cursor:pointer;
  /* CRITICAL: Prevent button scaling issues */
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
}
.topbtn svg{
  width:16px;
  height:16px;
  flex-shrink:0;
}

.menuOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:100;
}
.menuBox{
  background:var(--panel);
  padding:20px;
  border-radius:14px;
  min-width:280px;
  max-width:320px;
  position:relative;
}
.closeMenu{
  position:absolute;
  top:12px;
  right:14px;
  background:none;
  border:none;
  color:var(--muted);
  font-size:18px;
  cursor:pointer;
  line-height:1;
}
.menuSection{
  margin-bottom:16px;
}
.menuSection h5{
  margin:0 0 8px;
  font-size:11px;
  text-transform:uppercase;
  letter-spacing:0.5px;
  color:var(--muted);
  font-weight:600;
}
.menuItem{
  padding:10px;
  border-radius:8px;
  background:var(--panel-soft);
  margin-bottom:6px;
  font-size:13px;
  cursor:pointer;
  transition:background 0.15s;
}
.menuItem:hover{
  background:#24303a;
}
.menuFooter{
  margin-top:20px;
  padding-top:12px;
  border-top:1px solid #333;
  font-size:11px;
  color:#666;
  text-align:center;
}

.saveOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:50;
}
.saveBox{
  background:var(--panel);
  padding:18px;
  border-radius:14px;
  min-width:220px;
  max-width:90%;
  position:relative;
  text-align:center;
}
.closeSave{
  position:absolute;
  top:8px;
  right:10px;
  background:none;
  border:none;
  color:var(--muted);
  font-size:16px;
  cursor:pointer;
}
.saveAction{
  margin-top:12px;
  padding:10px;
  width:100%;
  background:var(--accent);
  color:#000;
  border:none;
  border-radius:10px;
  cursor:pointer;
  font-weight:600;
}

/* CRITICAL: Media query adjustments for high DPI displays */
@media (min-resolution: 150dpi), (-webkit-min-device-pixel-ratio: 1.5) {
  .tool {
    font-size:14px;
    padding:12px 8px;
  }
  .topbtn {
    font-size:13px;
    padding:8px 12px;
  }
  .topbtn svg {
    width:18px;
    height:18px;
  }
}

@media (min-resolution: 200dpi), (-webkit-min-device-pixel-ratio: 2) {
  .tool {
    font-size:15px;
    padding:14px 10px;
  }
  .topbtn {
    font-size:14px;
    padding:10px 14px;
  }
  .topbtn svg {
    width:20px;
    height:20px;
  }
}

</style>
</head>

<body>
<header class="title">Atelier</header>

<div class="overlayToggles">
  <button id="gridToggle" class="toggleBtn grid-toggle" title="Grid">
    <svg width="20" height="20" viewBox="0 0 24 24"><path d="M3 3h7v7H3zM14 3h7v7h-7zM3 14h7v7H3zM14 14h7v7h-7z" stroke="currentColor" stroke-width="2" fill="none"/></svg>
  </button>
  <button id="ratioToggle" class="toggleBtn ratio-toggle" title="Ratio">
    <svg width="20" height="20" viewBox="0 0 24 24"><path d="M9 3v18M15 3v18" stroke="currentColor" stroke-width="2" fill="none"/></svg>
  </button>
  <button id="rootToggle" class="toggleBtn root-toggle" title="Root Rect">
    <svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 4h16v16H4zM4 4l16 16M20 4L4 20" stroke="currentColor" stroke-width="2" fill="none"/></svg>
  </button>
  <button id="lockToggle" class="toggleBtn" title="Lock to Image" style="margin-left:8px">
    <svg width="20" height="20" viewBox="0 0 24 24"><rect x="5" y="11" width="14" height="10" rx="2" stroke="currentColor" stroke-width="2" fill="none"/><path d="M8 11V7a4 4 0 0 1 8 0v4" stroke="currentColor" stroke-width="2" fill="none"/></svg>
  </button>
</div>

<div class="topbar">
  <button id="menuBtn" class="topbtn">
    <svg viewBox="0 0 24 24"><path d="M3 6h18M3 12h18M3 18h18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
  </button>
  <button id="frameBtn" class="topbtn">
    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none"/></svg>
    <span>Frame: 1:1</span>
  </button>
  <button id="customFrameBtn" class="topbtn">
    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none"/><path d="M8 12h8M12 8v8" stroke="currentColor" stroke-width="2"/></svg>
    Custom
  </button>
  <button id="cameraBtn" class="topbtn">
    <svg viewBox="0 0 24 24"><path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z" stroke="currentColor" stroke-width="2" fill="none"/><circle cx="12" cy="13" r="4" stroke="currentColor" stroke-width="2" fill="none"/></svg>
  </button>
  <button id="importBtn" class="topbtn">
    <svg viewBox="0 0 24 24"><path d="M12 3v12m0 0l4-4m-4 4l-4-4M4 17v2h16v-2" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
    Import
  </button>
  <button id="saveBtn" class="topbtn">
    <svg viewBox="0 0 24 24"><path d="M5 3h12l4 4v14H5zM9 21v-6h6v6M9 3v6h6V3" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
    Save
  </button>
  <button id="clearBtn" class="topbtn">
    <svg viewBox="0 0 24 24"><path d="M3 6h18M8 6v14m8-14v14M5 6l1 14h12l1-14M9 6V4h6v2" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
    Clear
  </button>
  <button id="resetBtn" class="topbtn">
    <svg viewBox="0 0 24 24"><path d="M3 12a9 9 0 1 0 3-6.7M3 4v5h5" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
    Reset
  </button>
</div>

<input type="file" id="imageInput" accept="image/*" hidden>

<div class="stage" id="stage">
  <video id="camera" autoplay playsinline></video>
  <canvas id="overlay"></canvas>
</div>

<div class="panel" id="panel"></div>

<div class="toolbar">
  <div class="tool" id="gridTool">Grid</div>
  <div class="tool" id="harmonicTool">Ratio</div>
  <div class="tool" id="rootTool">Root Rect</div>
  <div class="tool" id="angleTool">Block-in</div>
</div>

<div class="menuOverlay" id="menuOverlay">
  <div class="menuBox">
    <button class="closeMenu" id="closeMenu">✕</button>
    
    <div class="menuSection">
      <h5>Learn</h5>
      <div class="menuItem" onclick="alert('How to Use guide coming soon')">How to Use</div>
    </div>
    
    <div class="menuSection">
      <h5>Upgrade</h5>
      <div class="menuItem" onclick="alert('Full version unlock coming soon')">Unlock Full Version</div>
    </div>
    
    <div class="menuSection">
      <h5>Resources</h5>
      <div class="menuItem" onclick="alert('Resources coming soon')">Educational Resources</div>
    </div>
    
    <div class="menuFooter">Version 1.0.0</div>
  </div>
</div>

<div class="saveOverlay" id="saveOverlay">
  <div class="saveBox">
    <button class="closeSave" id="closeSave">✕</button>
    <h4>Save Image</h4>
    <button id="downloadBtn" class="saveAction">Download</button>
  </div>
</div>

<div class="menuOverlay" id="customFrameModal" style="display:none">
  <div class="menuBox">
    <button class="closeMenu" id="closeCustomFrame">✕</button>
    <h3 style="margin:0 0 16px">Custom Frame</h3>
    <div class="menuSection">
      <h5>Dimensions</h5>
      <div style="display:flex;gap:8px;margin-bottom:12px">
        <input type="number" id="frameWidth" placeholder="Width" style="flex:1;padding:8px;border-radius:8px;background:var(--panel-soft);border:1px solid #333;color:var(--ink)" value="16" min="0.1" step="0.1">
        <input type="number" id="frameHeight" placeholder="Height" style="flex:1;padding:8px;border-radius:8px;background:var(--panel-soft);border:1px solid #333;color:var(--ink)" value="9" min="0.1" step="0.1">
      </div>
      <select id="frameUnit" style="width:100%;padding:8px;border-radius:8px;background:var(--panel-soft);border:1px solid #333;color:var(--ink);margin-bottom:12px">
        <option value="ratio">Ratio (unitless)</option>
        <option value="mm">Millimeters</option>
        <option value="in">Inches</option>
      </select>
      <button id="applyCustomFrame" class="menuItem" style="background:var(--accent);color:#000;font-weight:600">Apply Frame</button>
    </div>
  </div>
</div>

<script>
/* =====================================================
   DPI SCALING SUPPORT
   ===================================================== */
function getDevicePixelRatio() {
  return window.devicePixelRatio || 1;
}

/* =====================================================
   RENDER LOOP
   ===================================================== */
let needsRedraw = true;
function requestDraw(){ needsRedraw = true; }
function renderLoop(){
  if(needsRedraw){
    draw();
    needsRedraw = false;
  }
  requestAnimationFrame(renderLoop);
}

/* =====================================================
   AngleSlantedTool (UNTOUCHED)
   ===================================================== */
const AngleSlantedTool = (() => {
  let ctx, canvas;
  let lines = [];
  let active = false;
  let selected = null;
  let dragPart = null;
  let lastPos = { x: 0, y: 0 };

  function init(_canvas, _ctx) {
    canvas = _canvas;
    ctx = _ctx;
    canvas.addEventListener('pointerdown', onDown);
    canvas.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
  }
  function activate(){ active = true; requestDraw(); }
  function deactivate(){ active = false; selected = null; requestDraw(); }

  function onDown(e){
    if(!active) return;
    const p = pos(e); lastPos = p;
    const hit = hitTest(p.x,p.y);
    if(hit){ selected = hit.line; dragPart = hit.part; return; }
    const ln = { x1:p.x, y1:p.y, x2:p.x+120, y2:p.y+40 };
    lines.push(ln); selected = ln; dragPart = 'p2'; requestDraw();
  }
  function onMove(e){
    if(!active || !selected) return;
    const p = pos(e);
    const dx = p.x-lastPos.x, dy = p.y-lastPos.y;
    if(dragPart==='p1'){ selected.x1=p.x; selected.y1=p.y; }
    else if(dragPart==='p2'){ selected.x2=p.x; selected.y2=p.y; }
    else if(dragPart==='body'){
      selected.x1+=dx; selected.y1+=dy;
      selected.x2+=dx; selected.y2+=dy;
    }
    lastPos = p; requestDraw();
  }
  function onUp(){ dragPart=null; }
  function draw(c = ctx){
    if(!active) return;

    lines.forEach(ln=>{
      const sel = ln === selected;

      if(sel){
        c.save();
        c.strokeStyle = 'rgba(0,180,255,0.25)';
        c.lineWidth = 10;
        c.lineCap = 'round';
        c.beginPath();
        c.moveTo(ln.x1, ln.y1);
        c.lineTo(ln.x2, ln.y2);
        c.stroke();
        c.restore();
      }

      c.strokeStyle = sel ? 'rgba(0,200,255,1)' : 'rgba(255,255,255,0.9)';
      c.lineWidth = 3;
      c.beginPath();
      c.moveTo(ln.x1, ln.y1);
      c.lineTo(ln.x2, ln.y2);
      c.stroke();

      c.fillStyle = '#fff';
      c.beginPath();
      c.arc(ln.x1, ln.y1, 6, 0, Math.PI * 2);
      c.fill();
      c.beginPath();
      c.arc(ln.x2, ln.y2, 6, 0, Math.PI * 2);
      c.fill();

      const ang = (Math.atan2(ln.y1 - ln.y2, ln.x2 - ln.x1) * 180 / Math.PI).toFixed(1);
      c.fillStyle = 'rgba(255,255,255,0.85)';
      c.font = '12px system-ui';
      c.fillText(`${ang}°`, ln.x2 + 8, ln.y2 - 8);
    });
  }

  function hitTest(x,y){
    for(let i=lines.length-1;i>=0;i--){
      const ln=lines[i];
      if(Math.hypot(x-ln.x1,y-ln.y1)<12) return {line:ln,part:'p1'};
      if(Math.hypot(x-ln.x2,y-ln.y2)<12) return {line:ln,part:'p2'};
    }
    return null;
  }
  function pos(e){ 
    const r=canvas.getBoundingClientRect(); 
    return {x:e.clientX-r.left,y:e.clientY-r.top};
  }
  function clear(){
    lines = [];
  }

  return { init, activate, deactivate, draw, clear, isActive: () => active };
})();

/* =====================================================
   APP STATE
   ===================================================== */
const state={ 
  grid:null, 
  harmonic:null, 
  rootRect:null,
  activeRootRect:null,
  overlayVisible:{
    grid:false,
    ratio:false,
    root:false
  },
  gridOffset: { x: 0, y: 0 },
  gridScale: 1,
  lockToImage: false,
  frame: { x: 0, y: 0, w: 0, h: 0, ratio: 1 },
  frameEnabled: false
};

const framePresets = [
  {label:"1:1", value:1},
  {label:"4:3", value:4/3},
  {label:"3:2", value:3/2},
  {label:"16:9", value:16/9},
  {label:"2:3", value:2/3},
  {label:"9:16", value:9/16}
];
let frameIndex = 0;
const video=document.getElementById('camera');
const canvas=document.getElementById('overlay');
const ctx=canvas.getContext('2d');
const panel=document.getElementById('panel');
const stage=document.getElementById('stage');

AngleSlantedTool.init(canvas,ctx);

let cameraStream = null;
let cameraActive = false;

// GRID DRAGGING SYSTEM
let gridDragging = false;
let dragStart = { x: 0, y: 0 };
let dragStartOffset = { x: 0, y: 0 };

canvas.addEventListener('pointerdown', (e) => {
  // Only allow dragging if NOT in angle tool mode and NOT locked to image
  if (AngleSlantedTool.isActive()) return;
  if (state.lockToImage) return;
  
  // Check if any overlay is visible
  const hasActiveOverlay = state.overlayVisible.grid || state.overlayVisible.ratio || state.overlayVisible.root;
  if (!hasActiveOverlay) return;
  
  const rect = canvas.getBoundingClientRect();
  gridDragging = true;
  dragStart = {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  };
  dragStartOffset = { ...state.gridOffset };
  canvas.style.cursor = 'move';
});

canvas.addEventListener('pointermove', (e) => {
  if (!gridDragging) return;
  
  const rect = canvas.getBoundingClientRect();
  const currentX = e.clientX - rect.left;
  const currentY = e.clientY - rect.top;
  
  state.gridOffset = {
    x: dragStartOffset.x + (currentX - dragStart.x),
    y: dragStartOffset.y + (currentY - dragStart.y)
  };
  
  requestDraw();
});

canvas.addEventListener('pointerup', () => {
  if (gridDragging) {
    gridDragging = false;
    canvas.style.cursor = 'default';
  }
});

canvas.addEventListener('pointerleave', () => {
  if (gridDragging) {
    gridDragging = false;
    canvas.style.cursor = 'default';
  }
});

async function toggleCamera() {
  if (!cameraActive) {
    try {
      cameraStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}}});
      video.srcObject = cameraStream;
      video.style.display = 'block';
      cameraActive = true;
      // Turn off imported image when camera activates
      if (importedImage) {
        importedImage = null;
        updateClearVisibility();
        requestDraw();
      }
    } catch(err) {
      console.error('Camera access denied:', err);
    }
  } else {
    if (cameraStream) {
      cameraStream.getTracks().forEach(track => track.stop());
    }
    video.style.display = 'none';
    video.srcObject = null;
    cameraActive = false;
  }
}

function resize(){
  const dpr = getDevicePixelRatio();
  canvas.width = stage.clientWidth * dpr;
  canvas.height = stage.clientHeight * dpr;
  canvas.style.width = stage.clientWidth + 'px';
  canvas.style.height = stage.clientHeight + 'px';
  ctx.scale(dpr, dpr);
  
  // Calculate frame bounds if frame is enabled
  if(state.frameEnabled){
    calculateFrame();
  }
  
  requestDraw();
}

function calculateFrame(){
  const w = stage.clientWidth;
  const h = stage.clientHeight;
  const pad = 0.05;
  const maxW = w * (1 - pad*2);
  const maxH = h * (1 - pad*2);

  let fw, fh;
  if(maxW / maxH > state.frame.ratio){
    fh = maxH;
    fw = fh * state.frame.ratio;
  } else {
    fw = maxW;
    fh = fw / state.frame.ratio;
  }

  state.frame.w = fw;
  state.frame.h = fh;
  state.frame.x = (w - fw) / 2;
  state.frame.y = (h - fh) / 2;
}

video.addEventListener('loadedmetadata',resize);
window.addEventListener('resize',resize);
resize();

function draw(){
  const dpr = getDevicePixelRatio();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawToContext(ctx);
}

function drawToContext(c){
  const dpr = getDevicePixelRatio();
  const cw = canvas.width / dpr;
  const ch = canvas.height / dpr;
  
  // Determine the active rectangle: FRAME (if enabled) or COMPOSITION RECTANGLE
  let activeRect;
  if(state.frameEnabled){
    activeRect = state.frame;
    
    // Draw frame overlay (darken outside frame)
    c.save();
    c.fillStyle = "rgba(0,0,0,0.7)";
    c.fillRect(0, 0, cw, ch);
    c.clearRect(state.frame.x, state.frame.y, state.frame.w, state.frame.h);
    c.restore();
    
    // Draw frame border
    c.strokeStyle = "rgba(255,255,255,0.85)";
    c.lineWidth = 2;
    c.strokeRect(state.frame.x, state.frame.y, state.frame.w, state.frame.h);
  } else {
    // Use composition rectangle with safe padding
    const SAFE_TOP = 50, SAFE_BOTTOM = 80, SAFE_LEFT = 12, SAFE_RIGHT = 12;
    activeRect = {
      x: SAFE_LEFT,
      y: SAFE_TOP,
      w: cw - SAFE_LEFT - SAFE_RIGHT,
      h: ch - SAFE_TOP - SAFE_BOTTOM
    };
  }
  
  // Count active overlays for opacity adjustment
  const activeCount = Object.values(state.overlayVisible).filter(v => v).length;
  const opacityMultiplier = activeCount > 1 ? 0.7 : 1;
  
  // Track actual image bounds for lock-to-image feature
  let imageBounds = null;
  
  // Draw image inside active rectangle (frame or comp rect)
  if(importedImage){
    const iw = importedImage.width;
    const ih = importedImage.height;
    const ir = iw / ih;
    const rr = activeRect.w / activeRect.h;
    
    let dw, dh, dx, dy;
    // Fit image inside active rectangle
    if (ir > rr) { 
      dw = activeRect.w; 
      dh = activeRect.w / ir; 
    } else { 
      dh = activeRect.h; 
      dw = activeRect.h * ir; 
    }
    
    dx = activeRect.x + (activeRect.w - dw) / 2;
    dy = activeRect.y + (activeRect.h - dh) / 2;
    c.drawImage(importedImage, dx, dy, dw, dh);
    
    // Store image bounds for grids
    imageBounds = { x: dx, y: dy, w: dw, h: dh };
  }
  
  // Use image bounds if locked, otherwise use activeRect with offset
  const overlayRect = (state.lockToImage && imageBounds) ? imageBounds : {
    x: activeRect.x + state.gridOffset.x,
    y: activeRect.y + state.gridOffset.y,
    w: activeRect.w * state.gridScale,
    h: activeRect.h * state.gridScale
  };

  // Draw overlays
  if(state.overlayVisible.grid && state.grid) drawGrid(state.grid, c, opacityMultiplier, overlayRect);
  if(state.overlayVisible.ratio && state.harmonic) drawHarmonic(state.harmonic, c, opacityMultiplier, overlayRect);
  if(state.overlayVisible.root && state.rootRect) drawRootRect(state.rootRect, c, opacityMultiplier, overlayRect);
  
  AngleSlantedTool.draw(c);
}


/* =====================================================
   GRID DRAWING
   ===================================================== */
function drawGrid(type, c = ctx, opacityMult = 1, compRect){
  const dpr = getDevicePixelRatio();
  
  // Use compRect boundaries
  const w = compRect.w;
  const h = compRect.h;
  const ox = compRect.x;
  const oy = compRect.y;

  const baseOpacity = importedImage ? 0.4 : 0.5;
  const finalOpacity = baseOpacity * opacityMult;
  
  c.strokeStyle = `rgba(74,222,128,${finalOpacity})`;
  c.lineWidth = 1.4;
  
  if(type === 'spiral'){
    const cx = ox + w / 2;
    const cy = oy + h / 2;

    const a = 2;
    const b = Math.log((1 + Math.sqrt(5)) / 2) / (Math.PI / 2);

    c.beginPath();
    let first = true;

    for(let t = 0; t < Math.PI * 6; t += 0.05){
      const r = a * Math.exp(b * t);
      const x = cx + r * Math.cos(t);
      const y = cy + r * Math.sin(t);

      if(first){ c.moveTo(x, y); first = false; }
      else { c.lineTo(x, y); }
    }

    c.stroke();
    return;
  }

  // SQUARE GRIDS - cells are true squares, fit inside compRect
  if(type === 'square4x4' || type === 'square4x7' || type === 'square8x4'){
    let cols, rows;
    if(type === 'square4x4'){ cols = 4; rows = 4; }
    else if(type === 'square4x7'){ cols = 4; rows = 7; }
    else if(type === 'square8x4'){ cols = 8; rows = 4; }
    
    // Cell size based on smallest dimension to ensure squares
    const minDim = Math.min(w, h);
    const cellSize = minDim / Math.max(cols, rows);
    
    // Grid dimensions (may be smaller than compRect to maintain squares)
    const gridW = cellSize * cols;
    const gridH = cellSize * rows;
    
    // Center grid within compRect
    const startX = ox + (w - gridW) / 2;
    const startY = oy + (h - gridH) / 2;
    
    // Draw vertical lines
    for(let i = 0; i <= cols; i++){
      const x = startX + i * cellSize;
      c.beginPath();
      c.moveTo(x, startY);
      c.lineTo(x, startY + gridH);
      c.stroke();
    }
    
    // Draw horizontal lines
    for(let i = 0; i <= rows; i++){
      const y = startY + i * cellSize;
      c.beginPath();
      c.moveTo(startX, y);
      c.lineTo(startX + gridW, y);
      c.stroke();
    }
    
    return;
  }

  // Other grids - span full compRect
  const sets = {
    center:[[ox+w/2,oy,ox+w/2,oy+h],[ox,oy+h/2,ox+w,oy+h/2]],
    thirds:[[ox+w/3,oy,ox+w/3,oy+h],[ox+2*w/3,oy,ox+2*w/3,oy+h],[ox,oy+h/3,ox+w,oy+h/3],[ox,oy+2*h/3,ox+w,oy+2*h/3]],
    four:[...Array(3)].flatMap((_,i)=>[[ox+(i+1)*w/4,oy,ox+(i+1)*w/4,oy+h],[ox,oy+(i+1)*h/4,ox+w,oy+(i+1)*h/4]]),
    diagonals:[[ox,oy,ox+w,oy+h],[ox+w,oy,ox,oy+h]],
    baroque:[[ox,oy+h,ox+w,oy]],
    golden:[[ox+w*0.618,oy,ox+w*0.618,oy+h],[ox,oy+h*0.618,ox+w,oy+h*0.618]],
    dynamic: (() => {
      const phi = (1 + Math.sqrt(5)) / 2;
      const x1 = w / phi;
      const x2 = w - x1;
      const y1 = h / phi;
      const y2 = h - y1;
      return [
        [ox, oy, ox+w, oy+h],
        [ox, oy+h, ox+w, oy],
        [ox, oy+h, ox+x1, oy],
        [ox+w, oy+h, ox+x2, oy],
        [ox, oy, ox+x1, oy+h],
        [ox+w, oy, ox+x2, oy+h],
        [ox+x1, oy, ox+x1, oy+h],
        [ox+x2, oy, ox+x2, oy+h],
        [ox, oy+y2, ox+w, oy+y2],
        [ox, oy+y1, ox+w, oy+y1],
      ];
    })(),
    modular8:[...Array(7)].flatMap((_,i)=>[[ox+(i+1)*w/8,oy,ox+(i+1)*w/8,oy+h],[ox,oy+(i+1)*h/8,ox+w,oy+(i+1)*h/8]])
  }[type];

  if(!sets) return;

  sets.forEach(l=>{
    c.beginPath();
    c.moveTo(l[0], l[1]);
    c.lineTo(l[2], l[3]);
    c.stroke();
  });
}

/* =====================================================
   HARMONIC DRAWING
   ===================================================== */
function drawHarmonic(type, c = ctx, opacityMult = 1, compRect){
  const dpr = getDevicePixelRatio();
  
  // Use compRect boundaries
  const w = compRect.w;
  const h = compRect.h;
  const ox = compRect.x;
  const oy = compRect.y;

  const baseOpacity = importedImage ? 0.4 : 0.5;
  const finalOpacity = baseOpacity * opacityMult;
  
  c.strokeStyle = `rgba(96,165,250,${finalOpacity})`;
  c.lineWidth = 2.2;

  const r = {
    '1:2':[0.5],
    '2:3':[2/3],
    '3:4':[3/4],
    '3:6:9':[3/9,6/9],
    '4:6:9':[4/9,6/9],
    'sqrt2':[1/Math.SQRT2],
    'sqrt3':[1/Math.sqrt(3)],
    'sqrt5':[1/Math.sqrt(5)],
    'phi':[0.61803398875]
  }[type];

  if(!r) return;

  r.forEach(x=>{
    c.beginPath();
    c.moveTo(ox + w * x, oy);
    c.lineTo(ox + w * x, oy + h);
    c.stroke();
  });
}

/* =====================================================
   ROOT RECTANGLES DRAWING
   ===================================================== */
function drawRootRect(type, c = ctx, opacityMult = 1, compRect){
  const dpr = getDevicePixelRatio();
  
  // Use compRect boundaries
  const w = compRect.w;
  const h = compRect.h;
  const ox = compRect.x;
  const oy = compRect.y;

  const baseOpacity = importedImage ? 0.4 : 0.5;
  const finalOpacity = baseOpacity * opacityMult;
  
  c.strokeStyle = `rgba(192,132,252,${finalOpacity})`;
  c.lineWidth = 2.6;

  const cx = ox + w / 2;
  const cy = oy + h / 2;

  if(type === 'sqrt2'){
    const side = Math.min(w, h) * 0.6;
    const rectW = side;
    const rectH = side / Math.SQRT2;
    c.strokeRect(cx - rectW/2, cy - rectH/2, rectW, rectH);
  }
  else if(type === 'sqrt3'){
    const side = Math.min(w, h) * 0.6;
    const rectW = side;
    const rectH = side / Math.sqrt(3);
    c.strokeRect(cx - rectW/2, cy - rectH/2, rectW, rectH);
  }
  else if(type === 'sqrt4'){
    const side = Math.min(w, h) * 0.6;
    const rectW = side;
    const rectH = side / 2;
    c.strokeRect(cx - rectW/2, cy - rectH/2, rectW, rectH);
  }
  else if(type === 'sqrt5'){
    const side = Math.min(w, h) * 0.6;
    const rectW = side;
    const rectH = side / Math.sqrt(5);
    c.strokeRect(cx - rectW/2, cy - rectH/2, rectW, rectH);
  }
  else if(type === 'golden'){
    const side = Math.min(w, h) * 0.6;
    const phi = (1 + Math.sqrt(5)) / 2;
    const rectW = side;
    const rectH = side / phi;
    c.strokeRect(cx - rectW/2, cy - rectH/2, rectW, rectH);
  }
  else if(type === 'reciprocal'){
    const side = Math.min(w, h) * 0.5;
    const sqrt2 = Math.SQRT2;
    
    // Main √2 rectangle
    const rectW = side;
    const rectH = side / sqrt2;
    c.strokeRect(cx - rectW/2, cy - rectH/2, rectW, rectH);
    
    // Reciprocal rectangle (rotated 90°)
    const recW = rectH;
    const recH = rectW / 2;
    c.strokeRect(cx - recW/2, cy - recH/2, recW, recH);
  }
  else if(type === 'root9'){
    // Root-9 / Dynamic Symmetry construction
    const side = Math.min(w, h) * 0.7;
    const sqrt3 = Math.sqrt(3);
    
    // Main rectangle (1:√3 ratio)
    const rectW = side;
    const rectH = side / sqrt3;
    const x = cx - rectW/2;
    const y = cy - rectH/2;
    
    c.strokeRect(x, y, rectW, rectH);
    
    // Main diagonals
    c.beginPath();
    c.moveTo(x, y);
    c.lineTo(x + rectW, y + rectH);
    c.stroke();
    
    c.beginPath();
    c.moveTo(x + rectW, y);
    c.lineTo(x, y + rectH);
    c.stroke();
    
    // Reciprocal diagonals
    c.beginPath();
    c.moveTo(x, y + rectH);
    c.lineTo(x + rectW/3, y);
    c.stroke();
    
    c.beginPath();
    c.moveTo(x + rectW, y + rectH);
    c.lineTo(x + 2*rectW/3, y);
    c.stroke();
    
    // Vertical divisions
    c.beginPath();
    c.moveTo(x + rectW/3, y);
    c.lineTo(x + rectW/3, y + rectH);
    c.stroke();
    
    c.beginPath();
    c.moveTo(x + 2*rectW/3, y);
    c.lineTo(x + 2*rectW/3, y + rectH);
    c.stroke();
  }
}

/* =====================================================
   UI
   ===================================================== */
let openPanel = null;

function closePanel(){
  panel.style.display = 'none';
  openPanel = null;
}

gridTool.onclick = () => {
  if (openPanel === 'grid') {
    closePanel();
    return;
  }

  state.harmonic = null;
  state.rootRect = null;

  panel.innerHTML = `
    <h4>Grid</h4>
    <div class='option' onclick="setGrid('square4x4')">Square 4×4</div>
    <div class='option' onclick="setGrid('square4x7')">Square 4×7</div>
    <div class='option' onclick="setGrid('square8x4')">Square 8×4</div>
    <div class='option' onclick="setGrid('center')">Center Axis</div>
    <div class='option' onclick="setGrid('thirds')">Rule of Thirds</div>
    <div class='option' onclick="setGrid('four')">Quarter Grid</div>
    <div class='option' onclick="setGrid('diagonals')">Diagonals</div>
    <div class='option' onclick="setGrid('baroque')">Baroque Diagonal</div>
    <div class='option' onclick="setGrid('golden')">Golden Section</div>
    <div class='option' onclick="setGrid('dynamic')">Dynamic Armature</div>
    <div class='option' onclick="setGrid('spiral')">Golden Spiral</div>
    <div class='option' onclick="setGrid('modular8')">Modular 8×8</div>
  `;
  panel.style.display = 'block';
  openPanel = 'grid';
};

harmonicTool.onclick = () => {
  if (openPanel === 'harmonic') {
    closePanel();
    return;
  }

  state.grid = null;
  state.rootRect = null;

  panel.innerHTML = `
    <h4>Harmonic</h4>
    <div class='option' onclick="setHarmonic('1:2')">1 : 2</div>
    <div class='option' onclick="setHarmonic('2:3')">2 : 3</div>
    <div class='option' onclick="setHarmonic('3:4')">3 : 4</div>
    <div class='option' onclick="setHarmonic('3:6:9')">3 : 6 : 9</div>
    <div class='option' onclick="setHarmonic('4:6:9')">4 : 6 : 9</div>
    <div class='option' onclick="setHarmonic('sqrt2')">√2</div>
    <div class='option' onclick="setHarmonic('sqrt3')">√3</div>
    <div class='option' onclick="setHarmonic('sqrt5')">√5</div>
    <div class='option' onclick="setHarmonic('phi')">Golden Section (φ)</div>
  `;
  panel.style.display = 'block';
  openPanel = 'harmonic';
};

rootTool.onclick = () => {
  if (openPanel === 'root') {
    closePanel();
    return;
  }

  state.grid = null;
  state.harmonic = null;

  panel.innerHTML = `
    <h4>Root Rectangles</h4>
    <div class='option' onclick="setRootRect('sqrt2')">√2 Rectangle</div>
    <div class='option' onclick="setRootRect('sqrt3')">√3 Rectangle</div>
    <div class='option' onclick="setRootRect('sqrt4')">√4 Rectangle</div>
    <div class='option' onclick="setRootRect('sqrt5')">√5 Rectangle</div>
    <div class='option' onclick="setRootRect('golden')">Golden Rectangle (φ)</div>
    <div class='option' onclick="setRootRect('reciprocal')">Reciprocal Root Rectangle</div>
    <div class='option' onclick="setRootRect('root9')">Root-9 (Dynamic Symmetry)</div>
  `;
  panel.style.display = 'block';
  openPanel = 'root';
};

angleTool.onclick=()=>{
  AngleSlantedTool.activate();
  angleTool.classList.add('active');
};

window.setGrid = t => {
  state.grid = t;
  state.overlayVisible.grid = true;
  updateToggleButtons();
  closePanel();
  requestDraw();
};

window.setHarmonic = t => {
  state.harmonic = t;
  state.overlayVisible.ratio = true;
  updateToggleButtons();
  closePanel();
  requestDraw();
};

window.setRootRect = t => {
  state.rootRect = t;
  state.activeRootRect = t;
  state.overlayVisible.root = true;
  updateToggleButtons();
  closePanel();
  requestDraw();
};

function updateToggleButtons(){
  document.getElementById('gridToggle').classList.toggle('active', state.overlayVisible.grid);
  document.getElementById('ratioToggle').classList.toggle('active', state.overlayVisible.ratio);
  document.getElementById('rootToggle').classList.toggle('active', state.overlayVisible.root);
  document.getElementById('lockToggle').classList.toggle('active', state.lockToImage);
}

const menuBtn = document.getElementById('menuBtn');
const menuOverlay = document.getElementById('menuOverlay');
const closeMenu = document.getElementById('closeMenu');
const frameBtn = document.getElementById('frameBtn');
const customFrameBtn = document.getElementById('customFrameBtn');
const customFrameModal = document.getElementById('customFrameModal');
const closeCustomFrame = document.getElementById('closeCustomFrame');
const applyCustomFrame = document.getElementById('applyCustomFrame');
const frameWidth = document.getElementById('frameWidth');
const frameHeight = document.getElementById('frameHeight');
const frameUnit = document.getElementById('frameUnit');
const cameraBtn = document.getElementById('cameraBtn');
const importBtn = document.getElementById('importBtn');
const saveBtn = document.getElementById('saveBtn');
const clearBtn = document.getElementById('clearBtn');
const imageInput = document.getElementById('imageInput');
const saveOverlay = document.getElementById('saveOverlay');
const closeSave = document.getElementById('closeSave');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');

const gridToggle = document.getElementById('gridToggle');
const ratioToggle = document.getElementById('ratioToggle');
const rootToggle = document.getElementById('rootToggle');
const lockToggle = document.getElementById('lockToggle');

let importedImage = null;

function updateClearVisibility(){
  clearBtn.style.display = importedImage ? 'flex' : 'none';
}
updateClearVisibility();

// FRAME BUTTON - cycle through presets
frameBtn.onclick = () => {
  state.frameEnabled = true;
  frameIndex = (frameIndex + 1) % framePresets.length;
  const preset = framePresets[frameIndex];
  state.frame.ratio = preset.value;
  frameBtn.querySelector('span').textContent = 'Frame: ' + preset.label;
  calculateFrame();
  requestDraw();
};

// CUSTOM FRAME BUTTON
customFrameBtn.onclick = () => {
  customFrameModal.style.display = 'flex';
};

closeCustomFrame.onclick = () => {
  customFrameModal.style.display = 'none';
};

applyCustomFrame.onclick = () => {
  const w = parseFloat(frameWidth.value);
  const h = parseFloat(frameHeight.value);
  if(!w || !h || w <= 0 || h <= 0) return;
  
  let W = w, H = h;
  if(frameUnit.value === 'mm'){
    // Convert mm to ratio (no conversion needed, just use ratio)
  } else if(frameUnit.value === 'in'){
    W *= 25.4; // Convert inches to mm
    H *= 25.4;
  }
  
  const ratio = W / H;
  state.frameEnabled = true;
  state.frame.ratio = ratio;
  frameBtn.querySelector('span').textContent = `Frame: ${w}:${h}`;
  calculateFrame();
  customFrameModal.style.display = 'none';
  requestDraw();
};

// OVERLAY TOGGLES
gridToggle.onclick = () => {
  state.overlayVisible.grid = !state.overlayVisible.grid;
  updateToggleButtons();
  requestDraw();
};

ratioToggle.onclick = () => {
  state.overlayVisible.ratio = !state.overlayVisible.ratio;
  updateToggleButtons();
  requestDraw();
};

rootToggle.onclick = () => {
  state.overlayVisible.root = !state.overlayVisible.root;
  updateToggleButtons();
  requestDraw();
};

// LOCK TO IMAGE TOGGLE
lockToggle.onclick = () => {
  state.lockToImage = !state.lockToImage;
  if(state.lockToImage) {
    // Reset offset when locking
    state.gridOffset = { x: 0, y: 0 };
  }
  updateToggleButtons();
  requestDraw();
};

// CAMERA
cameraBtn.onclick = () => {
  toggleCamera();
};

// MENU
menuBtn.onclick = () => {
  menuOverlay.style.display = 'flex';
};

closeMenu.onclick = () => {
  menuOverlay.style.display = 'none';
};

menuOverlay.onclick = (e) => {
  if(e.target === menuOverlay){
    menuOverlay.style.display = 'none';
  }
};

// IMPORT
importBtn.onclick = () => imageInput.click();

imageInput.onchange = e => {
  const file = e.target.files[0];
  if(!file) return;
  const img = new Image();
  img.onload = () => {
    importedImage = img;
    updateClearVisibility();
    
    // Turn off camera when image is imported
    if (cameraActive) {
      toggleCamera();
    }
    
    requestDraw();
  };
  img.src = URL.createObjectURL(file);
};

// CLEAR
clearBtn.onclick = () => {
  importedImage = null;
  state.grid = null;
  state.harmonic = null;
  state.rootRect = null;
  state.activeRootRect = null;
  state.overlayVisible.grid = false;
  state.overlayVisible.ratio = false;
  state.overlayVisible.root = false;
  state.gridOffset = { x: 0, y: 0 };
  state.lockToImage = false;
  AngleSlantedTool.deactivate();
  AngleSlantedTool.clear();
  updateClearVisibility();
  updateToggleButtons();
  requestDraw();
};

// SAVE
saveBtn.onclick = () => {
  saveOverlay.style.display = 'flex';
};

closeSave.onclick = () => {
  saveOverlay.style.display = 'none';
};

// RESET
resetBtn.onclick = () => {
  state.grid = null;
  state.harmonic = null;
  state.rootRect = null;
  state.activeRootRect = null;
  state.overlayVisible.grid = false;
  state.overlayVisible.ratio = false;
  state.overlayVisible.root = false;
  state.gridOffset = { x: 0, y: 0 };
  state.lockToImage = false;
  AngleSlantedTool.deactivate();
  AngleSlantedTool.clear();
  updateToggleButtons();
  requestDraw();
};

downloadBtn.onclick = () => {
  const dpr = getDevicePixelRatio();
  const out = document.createElement('canvas');
  
  // CRITICAL: Set export canvas size accounting for DPI
  out.width = canvas.width;
  out.height = canvas.height;
  const octx = out.getContext('2d');
  
  // Scale the output context
  octx.scale(dpr, dpr);

  // Base: video frame if camera active, otherwise black background
  if (cameraActive && video.srcObject) {
    octx.drawImage(video, 0, 0, canvas.width / dpr, canvas.height / dpr);
  } else if (importedImage) {
    // Image already drawn in drawToContext
  } else {
    // Black background
    octx.fillStyle = '#000';
    octx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
  }

  // Overlays (image + grids + angles)
  drawToContext(octx);

  const a = document.createElement('a');
  a.href = out.toDataURL('image/png');
  a.download = 'atelier.png';
  a.click();

  saveOverlay.style.display = 'none';
};

renderLoop();

if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./service-worker.js");
}
</script>

</body>
</html>
